first i install the json package with npm init -y

then i install the express port which i will run on nodejs
then we have to downloaded the ejs and mongoose which we have to set up
now we have to show the databases which we right now using the mongoodb
first prompt is show dbs to show all of the dbs

then we have to create a folder of models and there we can create a listing.js: inside there we can set the constraint rules of nodejs and requiremongoose and schema rules on there.
const listing=mongoose.model
modules.export=listing; ("Listing", listingSchema); (with this way we can connect that constraint and export our rules)

#never ever fear of using docs when you forget it, it could be really useful to all to understand by doing it rather than remember it.
then we can use the certain rule that can applied on our all data that will be stored after that we can require that into app.js and check the server is working with new route
i have to extract the data and add them into object inside the array on data.js
then i can run node app.js and go to mongosh to check whether working or not

then our process would be first checking our server is that working after that create a get routing with listings url with res.render("app.ejs),{AllListing} (with allListings where all of our data is stored from tehe init data.js);
inside view create a views folder inside that listing folder to separate all of our ejs folder

when we rendering from app.get we generally use : res.render("index.ejs) but now we create a nested folder so we have to change into a "listings/index.ejs" which is a minor changes.
const Listing = require("../models/listing.js"); (sometimes also check that required is correctly set up the data.js with require)
after doing it check whether it is running the ejs or not with use the for (listing of allListings){ with li}here

i'm keep gettting the error which i finally solved after spending more than 2 3 hour on single problem the problem is that i run the node app.js and in my ejs folder it is not updating my database like only showing the previous data not updated only showing one title which it keep duplicate to multiple items. i solved first by commenting my previous data and then i improve the require(..models/listing.js) befor it was only one dot which main cause then when we searching on the parent directory we have to use double dot to find that specific . and then i first run the node init/index.js then run the node app.js which solved the error.

i can run the nodemon app.js which keep constanlty refresh when i change anythiing on my code i installed this as a global variable from npm which i don't need to download the every time.

then our next steps is to create other route mainly :id route which we can go to specifc listing to check it.
app.use(express.urlencoded({extended:true})); (it will prase the incoming bodies);

#the imprtant things while sendind data from the server to client side is while using the ejs: app.set("view engine", "ejs");
app.set("views", path.join(__dirname, "views")); (first it will set the ejs files will be created, in the views folder of the directory name.)
the app.set method can able to control the view enginer and static file served of html, css and js. the second line tells that where our folder is. and __dirname is set the absolute htat path. 
app.use(express.static(path.join(__dirname, "public"))); (This serves static files (e.g., CSS, JavaScript, images) from the specified directory.)
__dirname:
This is a Node.js global variable that gives the absolute path of the directory containing the current file (e.g., app.js).
Example: If app.js is in D:\Project\my-app, then __dirname will be D:\Project\my-app. the path.join is utlity into single path. 
in her: we set up the app.use a middleware function remember that.
#in here first we have to require the path which we have used on the path.join . with const path=require("path"). 


after that i created the show.ejs and connected show.ejs to the new route of :id.
now i create a new route of new.ejs with create a new button of create a new list.
while creating a form remember that give it a name of the form input format that could align with our database to directly save our data.

it will encountered the one error we create a first :id and then new now backend will try to understand the new of keyword which we don't want, so for this issue solve just use the new route before :id route.

with in post method i have first extracted all of the data with have to be a same name on form for easier .

# req.body and req.params difference:When working with `req.body`, it's used to extract data sent from forms (usually in POST requests), where the data is hidden and not visible in the URL. On the other hand, `req.params` extracts data directly from the URL (commonly in GET requests), where the data is visible and part of the URL path.

we can use the req.body method but also we can use the different approach to send the frontend data to backend with post request.
    <input type="text" name="listing[title]" > (our object name would be listing and inside that it will be key name called title);
    with this method our code syntx become more shorter on app.post method.
      let listing=req.body.listing;
  new Listing(listing); (this is the another approach to get the post methdo but there is even shorter method to do this post approach, new is a keyword remember that)
i first i changed into this for shorter syntx: 
  const newListing=new Listing(req.body.listing);
  await newListing.save();
  console.log(newListing);
(in here i also .save(), which i stored the data on my database, then i insert the data on object format and await which is the asynchourns function and print the newListing to check whether my data is correctly added or not);

    <form action="/listings" method="POST"> 
 (there is the one error on my before this i have send the action method to /views/listings/index.ejs, which is the wrong method, so i have change the action method to only /listings which is working right now.)

 //now i'm working on the edit and update route which is come under the crud opeartion first i created the both route


 we have to edit & update route with perform on 2 steps with both get and post request
instead of using the placeholder to show the previous non edited data we can use the value method on html form to make like textarea, with in build value.

method-override is used when we want to use the put and delete method, it's as an npm package, now i have downloaded method-override i can use the put package on the edit.ejs. (method-override is middlwaare of express of put, patch and delete)
now i send on the edit.ejs:   <form action="/listings/<%=listing._id%>?_method=PUT" method="POST"> (it will send the method on POST request but it will converted into the PUT request with the help of method-override)
then i first require of methodoverride on app.js and then i have to use the : app.use(methodOverride("_method")); (why do we use methodOverride cause we give the value of require method same name and _method why do we use this cause we use the same format on edit.ejs form method);

now we use the app.put method on the app.js to do the logic of put request which will evenetually update the new value.
req.body.listing is a javascript object which there is all of the parameter what we require. first we deconstruct the id and then we will convert into the individual value.
  Listing.findByIdAndUpdate(id, {...req.body.listing}) (the spread opearotr ... is a fastest way to take all property what we required, it helps us to make code cleaner in better way)

     <select name="listing[country]" id="">
        <% const countries = ["Nepal", "India", "Bhutan", "Japan", "South Korea", "Indonesia", "Bangladesh", "Thailand"]; %>
        <% countries.forEach(country => { %>
            <option value="<%= country %>"><%= country %></option>
        <% }) %>
    </select> (generally when we create a other types of input format it generally doesn't allign above i create the selection with dropdown which in normal way it will not align but with this way it align with the code i have to understand this code deepsly in future)

delete routing which will destory the routes
i have tried without doing async and await which takes too much time to take the deletedtion which i use the async and await method which is really helpful to me.

//now as shradha khapra used the ejs-mate which is the npm library for like creating a template inside the ejs files


//middlewares is the important topics on backend which i have to learn right now till now i have learn  

it's an intermediatery between request and response. middlewares are not only in nodejs in general program world we can see the middlewares everywhere, right now.

middlwares in express functions that come into play after the server recieve an request and before the response is send to the client.
some common middlewares functin are: methodOverride (it uses for the use of the method such as put, post & delete), bodyParser (when request body have the data, the request/backend/server doesn't understand . we have to parse that data for the understandable form), express.static(it will used for the backend static static files to serve to the clients side. static files:related css, related javascript, any image that static files we have to serve to the client we use express.static), express.urlencoded(it is same we get the acess inside request access.).

app.use(express.urlencoded({extended:true})); (the urlencoded is the middlewares function here on this code, )

app.use(why do we use the app.use , when there is the request comes from anywhere like get request, post request, when that happened what we wan to perform is that's why we use the app.use)

the things that every middlewares have:
the req and res which is the object can acess from the anywhere, also what response it should go can also access the middlwaare.
in one middlewares that's the possiblity of that could have the chaining. 
let's ex: there is the request comes and we have to do multiple things at once it can be possible like chaining.
if middlwaare he can send the response and stop the chaining process.
in the case initially middlwares when the code started respons is send first it will send then other code executed, 
middlwae execute any code
middlwares end the request-response cycle.

middlware have only 2 choice, 
he can send responsed or either middlwares can call the next middlwares. like it will call the upcoming middlewares and handle the all of the remaining tasks.


//now continue to our mega project

validation error--
when we enter the data on forms the client/browser will check the data is that data matched with our constraint? due to incorrect data our website could be the updated and can cause the multiple error on our database.

there are 2 mainly validation : client side validation and server side validation:
client side validation means use put the unintended data, unfullfiled data for ex: in locationo user put the title, it is the client side validation
server side validation is check the constraint rules if they are matched with out filters, if yes user then only can fill the form.


when we build the project , our intend always have to be that webpage can anyone access by any browsing method, and that should be easily accessible to increase our website traffic.


the next things i have done is add the boostrap classes to my new.ejs file for better looks.
with the helps of i create an success and failure message as a client side form submission.

then i use the custom error handler to handle the error if use create a listing without filling data, as i already done that with the boostrap but this is the custom error handleer logic.
first i use th app.use (with all 4 parameter and i send the response in case there is the error) and above in listings i use the try and catch i passed the next(err) on the catch method.

i create the utils folder where i added the extra things like: error class,  valid synchrounousation and more like this other files.


create the custome expressError 
first i create an expressError.js file inside utils folder inside that i passed the passed with like thi:
class expressError extends Error{
  constructor(statusCode, message){
    super();
    this.statusCode=statusCode;
    this.message=message;
  }
};
The super() function in JavaScript is used to call the constructor of the parent class. In ymyour example, the expressError class extends the built-in Error class, which means expressError is a subclass of Error. The super() call is required to properly initialize the parent Error class.

module.exports=expressError;

first i use the app.use("*") to select the non existent route and i passed the next( new expressError(404, "error"))
then i use the app.use(()) which i do like let{status, message}=err. and i send it into res.status(status).send(message);

with this now my route is working now.( in default use the status 404 for avoiding other error)
now with this way it send the proper error without crashing the app.
where there is the async function on route just use the wrapasync to avoid conflict of non existent routes. while doing the asynchrounus opeartion it is become essential to handle the operation such as if error occures handles that error before got stuck on anywhere.

staus 400 mean bad request. which mean due to client mistake, server can't handle the request.

http://localhost:8080/listings (when i send request as a post format which is the non existent in post format, if we send this request we got error like this: Listing validation failed: title: Path `title` is required. )


  if(!req.body.listing){
    throw new expressError(404, "listings is not valid")
  } (i add this condition on inside /listings for check if that condition not matched send the error: i check with post request and i got the error, that mean my server is working now)


  till now the error is showing only in res.send which is the not good way to show the error, for showing the good way is to create an error.ejs.


  i have to do the ejs mate way back but right now i am doing.
  ejs mate helps us to create the multiple ejs template that we can use . like we can create an separate header and footer. 
  the topic also include/partial which are similar logic that we can use 
  app.engine("ejs", ejsMate); (with this way i imported the ejsMate to my project.)
  //this is similar to the require

  i first create an layout folder inside views folder inside that i create an boilerplate.ejs. i write the :     <%- body %> (inside of the boilerplate to connect to other ejs template),   <% layout("/layouts/boilerplate.ejs") -%> (then i use this on top of page to show to ejs wheere we want to use it.)
  the cleaner way to write the code is separate smaller section into different files , in future , we can easily able to find those where we want to find it. it also the best approach to write the code.

  now i have update lot of things create an separate folder for the header and footer and connect them to boilderplate and conect them with main.
  update lot of css things.

  now i will learn the ejs erros. @with the help of the deepseek i fixed the navbar fixed.
  
  now i am currently doing the error.ejs file improvement.
  with showing the err.message we can also trace like: err.trace, err.stack. for showinng the error message.


  schema validation :
  first i send the request on the same url with post method from hoppscotch and inside on body i added the custom value, in other it is running it is showing 404 error which might be the custom errror.

  like from hoppscotch we can also even send the data but in there in our own way we can save the data but only valid response should be on the data can make from schema validation:

  in app.post method:
  i can simple apply the if condition with send the throw like this:
  let list=new list(req.body.list);
  if(!list.title){
    throw new expressError(404, "title is missing");
  }

  it will becomes the repetative if we want to apply for multiple, for this task to make effiect we use the tool called: Joi (joi.dev)
  joi task is to validate the schema, this is also the server side validation.

  now i created the new file named: schema.js., which will require the joi the and applied the rules with our own way.

  const Joi=require("joi");
const listingSchema=Joi.object({
  listing:Joi.object({
    title:Joi.string().min(5).required(),
    description:Joi.string().min(5).required(),
    image:Joi.string().allow("", null),
    price:Joi.number().min(0).required(),
    location:Joi.string()..required()
}).required()
}); (first i required the joi, then i create a list of rules, like in first inside listing inside object title should be required format is string, like this and image also allow the blank or null value) (i module exports with before listingSchema i added like: module.exports.)

then i required the joi package and next step is to use the do like this: listingSchema.validate(req.body) (from the request body it will check whether the condition are fullfilled or not)

with i print the listingSchema value if we send the request and joi will identify that error and console on terminal

like in just here we will use the conditon like if joi throw and error we wil throw an error

validation for middleware:
first i create the function for the validate lisitng with middleware and also pass next if all of the condition is passed.

first we will validate the listing schema from the request body that data is come. from the result we will extract the error with define the let {err}, i use the if else conndition like if(err) is comed throw the request else call the next.

now we will add that function in this route to cheeck the condition that we are trying to check the schema validation.
i use this function on : app.post("/listings), app.put("listings:id), 

till now we have learn the client side validation, server side validation, also we manage the effectively handle the error with custom error with next call and middleware.

if we got the error in reponse we get the response on object form. for extracting them, 

      let errMsg=error.details.map((el)=>el.message).join(","); (i added this conditon for if we get the multiple error, we can handle it, in default error are comes in object format with .map i convert them into the string, and if there is the comma on that array just also join with main error ,.join method used to join the all element of the array into the single string.
  the phase one has been completed of the project now it will start the phase 2.

  


project, phase 2:
in mongodb relation topic we will cover new topic named: 
handling deletetion using mongoose middleware. 
we can use the 2 middleware: Pre & Post. 
one example:
like when we delete our instagram the data related to that username would also deleted like, story and posts. we called a handling deletetion. if one main model is deleted, it will check does that model have any connected model data stored, also those data would be deleted. it also called a cascading deletetion.
how can we implement: we create a customer model and orders model. in customer model there is order id exist and also order product.  we called this mongoose middlewares. 
the mongoose middleware are little bit difference from the express midlleware. 
there is the types of middleware like: document middleware, query middleware, we will focus on query middleware. query middleware executes when you call exec() or then() on a query object. or await on a query object. in query middleware functions, this refers to the query itself.





//creating a reviews model. which will show all of the reviews.
in reviews we will only showing reviews, rating (1 to 5), created at(date will now show to the client server only server side.)
first inside models i will create a another file called reviews.js, which will value all of the constraints.
in date i have added the date and in default it will store the value of current date.

in reviews.js file i created a simple contraint on js, and at the end, i exports that same modeel.
then in listing.js i also create a another variable, inside that array it would be the array, instead of type: String, we will use the type:Schema.Types.ObjectId. will store like this. 
revise above: in listing.js i create a reviews inside that i store the array with given a objectId. why objectId because this is the one to many relationship of database. on one listings, there could be the multiple of revieews, which why we use th one to many . in many it will only use one to few or one to many, as there it would not stored the one to squillion method. we also have to use the ref, to which reference which we are reffering, in this we use the Reviews, method on there.

now i will create the form on show to give review on the form method.
inside the show.ejs i created a 1 form last of the page with form method with get method and give stylying of how our form looks on frontend.
first we have to understand that we don't create a separately the reviews part as is will have the relationoship with the listing db, so we will use the one many relationship, with the so we will use the   post: /listings/:id/reviews method for access that review. remember that it will have the one to many relationship with listings. we will just conenct them.

 now the functionallity part is that first i require the reviews.js with same like listing.js and then i use the post method on form. then my next task is to create a post route. why don't we create a get route(because we don't need to show the review in separate page, as we will access them in any connected listings, that's why we don't require to use the get method.)

 inside post route i give the post route first, for accesing that particular id:
 app.post("/listings/:id/reviews", async (req, res)=>{
 let idReview= await Listing.findById(req.params.id);
  let newReview=new Review(req.body.review);
}) (first on idReview i get the id access, and that particular id stored on the idReview, and the review i store on our ejs: name[reviews], is stored on here.)


the errror i am causing is that: the name is mismatched which wasted my over the 2 to 3 hours to solve just basic problem. 
now i make the comments required to users to add anything.

now we will do the client side validartion first then server side validation.

now i create a needs validaton boostrap javascript code inside public folder with js folder. now i have to connect them with boilerplate first. then i could use on our ejs. 
now in every page that validation can run now with using the class on boostrap. we can prevent user from sending blank on reviews, but user also can send the request from hoppscotch with blank . so we have to fix that, till now our server side is not complelety safe like any user can send the request, using hoppscotch.

for validating the server we use the joi to validating this, in the reviews we will also use the joi for that. for joi schema validating, we have made the function, then we passed as a middleware with app.post method. 
now inside schema.js i will create a validation method and pass as a function.
after creating i require on app.js with the listingSchema, then i will create the same function and then pass that function, then we can't send the request from any external site.
but remember that, in the error body changeed the name to what have you required.
the next process is to show our reviews, before that i will remove the empty value commments which i have created a empty comment during a testing. this is the commands: 
db.reviews.deleteOne({_id: ObjectId("67acbc16bd2e7573243c3715")}) (with this i remove that particular objectId review, from the database)

render our reviews, like show the review that is stored on our database.
first i will see the with just pass the object id to check whether my server is working or not.

# we can't directly access the value and data inside of reviews at that time we can simply use the populate method to extract inside that value. 
  const listing = await Listing.findById(id).populate("reviews"); (with the populate method i can get the acces of reviews, now if i only print the value now it will print the entire value with comments and rating.) 
  

we don't only want to get the reviews also we want to get the data of the review, at that time we only get the object_id and with for of loop we can get the data of inside reviews.

now we want to styling our reveiws. our revewes, will show on the card forms. with using the boostrap i convert into the boostrap. 

our class name of boostrap card becomes same so my above image inside the show.ejs i have to create a another class name -lising-card and i use that on the css. 
i have to make the 2 cards to come on 1 line.

we will use the mongo pull operator,  the $pull operator removes from an existing array all instances of a value or values that match a specified condition. it is a operator like: $set, $in and $between operator. 
then i will create a form with delete button. with method post and action would be reviews/<%-listing._id %>.

deleting our reviews, first we creaate a button below the reviews, to delete the listing. then we create route of /lisings/:id/reviews/:reviewsid . first it will delete from the review database, and also it should delete the reviews from our lisitngs database.

then my next processs is to get the id of both id and review id with req.params. then in Listing i would use findByIdAndUpdate method inside of it with id, then it will update with deleted on our database the listings database of the reviews. with findById i will delete that specifically reviews database from insdie the listings database and the reviews database.
delete middleware reviews:
in inside listing there are multiple reviews and if we deleleted teh listiing inside that reviews it should also be deleleted. 
if we just check on the database: 
db.listings.find({title: "Mountain View Apartment"})
[
  {
    _id: ObjectId("67a5cfc1b613465076f53dd7"),
    title: 'Mountain View Apartment',
    description: 'Enjoy panoramic views of the Himalayas from this modern apartment in Kathmandu.',
    image: 'https://cdn.pixabay.com/photo/2015/05/30/12/46/nepal-790335_640.jpg',
    price: 800,
    location: 'Kathmandu',
    country: 'Nepal',
    __v: 2,
    reviews: [
      ObjectId("67ad8d22b683be2fe2ccb9e4"),
      ObjectId("67ad8d31b683be2fe2ccb9eb")
    ]
  }
] (it shows 2 object it mean that there is 2 reviews store.)
for deleting also that, we will use the post mongoose.
first i required the model on listing.js: const Review=require("./reviews.js");
before this: 
listingSchema.post("findOneAndDelete", async (listing)=>{
  if(listing){
    await Review.deleteMany({_id: {$in: listing.reviews}})
  }
}); (when we are trying to delete the any particular listing with this $in method it will also deleted those correspondecee reviews, it is working now.)

now i will learn about the express router. 

now first i will restructured of my listings. 
first i will create the another folder called routes. inside the routes i create a file called listing.js inside that i will require the express, then i will create the route route, with const router=express.Router() i created a router.

inside of app.js, all of the listing method router will copy to the listing.js inside the routes.
first i required the express, then i i created a route with like this: const router=express.Router(); and also i module.exports=router;
const listings=require("./routes/listing.js") (this is the method to require from the routes folder inside the listing.js )
app.use("/listings", listings) (i also have to redirect it)

till now there is lot's of error on my server which i have to solve, here is my the errors:
in listings routes, we have use the lots of middleware like validateListing, validateReviews, i also have to required on the listing.js inside of routes. also on above there are lots of things that requires which we haven't required on the listing.js.

first we have to requied on also on listing.js like on app.js: wrapasync, listingSchema, expressError then also other required such as: Reviews, Listings.

the one thing i have to fix is that: const Review = require("./models/reviews.js"); (this is the required method and i just have to add doble .. to make "../models , cause it will now trying to find the folder in parent directory rather than current directory.)

the error i am keep facing is that on listin.js inside routes: const Listing = require("../models/listing.js"); (i make the ../routes which i should make /models this is the error.)

new topic:
express router, cookies:

 this are the miscellenouis topic of express router:
 we will learn with doing restructering how we can make our express router better. and some basic conecpt of cookies. this concepts we will apply later.
inside app.js we write the lots of code there. if we created a new modes and in app.js it will becomes the more lined coded. at one point to read the entire file would become too difficult.
 now we will resturcuted our code with the helps of express router.
it is not compulsory to use the express router but generally in good websites. in large scale website it is used the express router. 
when code divided into smaller parts it would become easy for us to understand. the one example definetly would be the views folder inside listings folder.
so it is useful to use teh express router in our projects.

experss router are a way to organize your express application such that our primary app.js file does not become bloated.
const router=express.Router() (it creates a new router object)
 
a router object is an isolated instance of middleware and routes. you can think of it as a mini application. capable only of performing middleware and router function. every express application have the build in app router.
for understanding this concept better we can create a new folder named a classroom, we will delete later we just now to understand the basic concepts.

inside server.js i just use the 3000 port to check whether working or not.
till now we have only create a only users route. 
now we will create a multiple of users and post routes inside of server.js.

i created a multiple of routes, with both for users and posts and i check it is working now.
now inside classroom i created a another folders called routes.
we trying to destructered the same routes inside routes. above on new server.js there are multiple of related routes /users. till now we have created a different routes on same file now will separate with users to another and posts no another to not make bloated code. 
inside routes we will create a separate files to separate them.
i created the post.js and user.js inside routes of classsroom folder. in there i first move the users only routes to users folder.
 now we have to create a router object, for createing router express object have the Router method to create a new router like: const router=express.Router().

we don't require to use the app.get now instead we can just use the router.get. then we also have to module.exports =router. for using the user.js we required them on our server.js file.
still now our code won't work, the different paths we required them on router object but we have to use them, for using them we can use the app.use("/", users); (the all of the path used users what we required above. what does it mean this code: the all of the routes that we send them the request, whose routes start with "/' will try to matched the remaining of paths. then if there is the commong things on our routes in inital stages like "/users" is common here, so we write the common path on here: app.use("/users", users); on app.use to send the request.)
now we can remove the common things of the router path from the user.js like app.get("/users") users is common on all of the paths we can simply do the : app.get("/"). now in future if we want to change something on user routes we don't required to go on server.js, just simply we can go on user.js to change something.
now i have the same things to post.js first i moved the all post router to post.js and then i required a express and also teh router. then i rename the app.get to router.get. and then i module.exports=same name as Rotuer. module.exports-reouter.  first i use the posts with required that particular file(if it is on parent use .. if on same file use: . and then i use the :   app.use("/posts", posts);
 for common path and on post.js i remove the common part.)

cookies:
http cookies are small blocks of data created by a web server while a user is browsing a website and placed on the user's computer or other device by the user's web browser. 
we hav go lot's of new websites, generally it shows the option to accept the cookies or reject the cookies. we will learn what is cookies, how can we use them on our websites. we will try to understand the basic concepts of what the usage of cookies. cookies mean the web cookies (we also call them the web cookies). 
cookies are tiny block of datas that stored on the web browser. who send and who store: it stored and send on the web server. 
what's the usage of cookies:
session managment: usually back in days, the website don't store data on database, like on shopping website when they added a cart and go to any page the stored card is store on cookies.
tracking: it will get the info of what websites you frequently visit, what topic you are intersted. then browser will track you and based on that you will see the targeted ads.

we will only learn the personalization topic uses not other:
pracitcal examples like when you swtiched to the dark mode on any page with the help of cookies it will implement on all of the pages, also on facebook once you logged in you don't required to login again.
generally cookies are paired on like key value pair on json format. you can see which website store your cookies or not on application on inspect page. 

how to send cookies using express:
inside setCookies route of localhost:3000 i send cookies with this way:   res.cookie("name", "dipesh");   res.cookie("country", "Nepal"); (this are the key value paired, cookies. with we can send multiple cookies, for checking, we can simple go application inspect and inside cookie you can seee key value and everything, once we send the value of cookies, it will store on that website whether you go another page, or come back after several days. (for get that cookies we have to go to that route first to run on our website.))
we can read the docs on express webiste with res.cookie area.

cookie parse package:
one route can access that cookies now, but we want that another routes want to access that cookie or want to parsed (read) it. 
on request the cookies are generally stored, req.cookies are there if we print the req.cookies . we can access the cookies. let's say we want to print the cookies on the root routes. we can do console.dir/console.log.

from once setCookies is send the cookies, it will always have on other root of that cookies stored. if we go to localhost:3000 it will print the undefined on console. why?: because directly parsing the cookies on express is not possible. we have to use the middleware,  called: cookie-parser.
first we have to install it's npm package.  then first i required and created a middleware, whenever new request comes first it will go from the cookieParser middleware then it can parse the cookies to any routes. required methd:const cookieParser=require("cookie-parser");
app.use(cookieParser()); (this is the middleware method.) now it will show our cookies data.
if we want we can add manually the cookies. with add new value i just added thew new value manually and it console on terminal.
cookies nothing it just piece of information. now i will create a new route called greet route. 
usually for related authorization, authotication we can done by cookies. 
like if we want to add any value of default we can do that with:   let {country="masters"}=req.cookies; 


signed cookies:
basically there is normal cookies and there is signed cookies which mean that similar to physicl sign. like it put the stamps/signs. for example we take the water bottle from the market, like if the sealed is broken we thoght that is not healthy what we thought is that the bottle integreity is lost. so with using the browser manually we can change any cookies value or add cookies. so that mean we have done tempering with the cookies. for save from the tempering or unintinally value saved we use the signed cookies. 
after sending the signed cookies we verify the signed cookies. like checking is that is that is the signed cookies, so that is the 2 step process. 
we can set the property for signed cookies, when we send the cookiees with it if we est the {signed: true} . for creating the sign cookies, in app.use cookieParser we have to send teh "secretCode"/additional string ,  for signed cookies. the signed cookies then it will not go on raw form , then it will go on encoded form which is the unreadable form. even we can read that data. with the value we attached the code then with the help of it becomes the sign. 
after setting the app.use("secretCdoe"), res.cookie({signed:true}), it becomes sign now.
i created a another route name /verify. in verify route:   console.log(req.cookies) if console the req.cookies, and go to /verify route the intersting things come like it print the empty object, but if we try to add any key value from the application it will print that value into console. but it will not print the signed cookies value onlly it will print the value that you are trying ot add on browser manually. for accessing the signed cookies , like if someone try to change those value or get access, we can use the req.signedCookies. then the signed cookies will print the separately. in print normally . but how can we verify that whether someone is changed the value or not. like if i changed the entire signed cookies value to something else now it will just print the empty object. but like signed cookies value are like this: s%3AjavaScript.lu9eaFQh%2Fu4YiE%2B3mGwjs0 and if we changed the javascript into like Express with changing only value then it will show the name into false, that mean we have tempering our value. 



State:
protocol mean what kind of request is going what kind of response is going. the rules request, response follow called a protocal.
  
Stateful Protocol: Stateful Protocol require server to save teh status and session information. eg: ftp (file transfer protocol).
Stateless Protocol: Stateless Protocol does not require the server to retain the server information. (it does not store the information of server or any session) eg: http. (till now with using the http protocol we are doing the development)

when client is interacted with our website, and comes one times we called a single session. 

when we have to pay the money to anyone, if we pay the money through physically it can call the stateless protocol as it doesn't have the any background info but if we pay through upi , we could track the payment , we can simply compare with the stteful protool.

express Session: it's attempt to make our session stateful. session related information stored on the server side. like: for ex: for every user on instagram they are assigned to any unique session id, if they added any product it will stored inside that session id. like on for every unique id user. express session will store only one session info. like the session id is stored on the form of cookie format.
why does it important: some customer are added some item on their carts like laptop and they switched on adding the any sportss product, should laptop added cart should be deleted, no absoluletly not, if we just use the stateless protocal it will not stored, but with the stateful protocal we can stored that.
this information is not stored on database cuase database work is to save the information on pernamnet basis. the next question is arise why do we stored the information on server side. in cookies there is the limit, to save the information of the limit. it is quite less compare to temp storage. as well teh information we stored on cookies is not that secure. in cookies we just stored the session id not the entire data items. 
now we will learn more about with implement the practically: 

current important things to understand is that: the express-session work is that: it creaeted a session id for creating the temporary  storage store the data. 
for testing the expres-session i created a new folder called express-session(but other are doing inside on classoom folder) and inside of it session.js and first i required a express and listen port. 
now i first i have to install the npm package : called express-session, then i required on session.js with name session. for using the express session. as this is the middleware we wil have to use the: app.use(session()) (inside session we can use the differnt differnt option, the options are: cookie, but for now we only have to know the secret. secret is the required option for the current session we have to be the secrets )
 as this is the sign-cookie and for the sign cookie it is required the secret code it also required here. this can be either a single string or multiple of array. a secret should not be easily parsed by human as it would best need random set of character. we update the secret code timely. app.use(session({secret: "secret"})); (inside session it should be secret code.) (it will comes 2 errors we can ignore that. )
 now i just test on /test route. with on inspect application with deleted the existing data i can see the new data on tehre called connect.sid. this is the unique session id.
the one things we can notice on there, on cookies we can see even if we go to another tab on same browser that we can see thee session id same. like on above given value connection id ans beloe cookie value connection id are same cause: within one browser if we open the tab on different tabs, the express with treat that as a 1 session. for example if we try with another browser we can see there the different session id. for using the same property . 
i will create a one route to count how many we have open that session with counting. till now the count is not tracked like counting how many times we have visited. we first count with req.session.count. then we added te condition if exist it will increament else it will initiated to 1. 
  if(req.session.count){
    req.session.count++;
  }
  else{
    req.session.count=1;
  }
  res.send(`you visited the website ${req.session.count} times.`) (with this condition i increament to 1 of the count, even it will work on new tab. req.session will track the single session. )
sesion mean that client is sending the response to server and vise versa, this is the practical examples of how session would be used. the one things that noted is that the session of count is stored on the temporary basis. in express there is the warning related to the express-session. the default server side session storage which we also called a memoryStore, is not purposly not designed for the production envionment. 
in express session the warning are coming here, for removing them we have to add 2 option name called, resave and saveinitialized option. the resave foreces the session to be if the session, in resave whether the the changes/modified or not it will resave to the session. then the resave by default we will set false for avoid any terminal deprecated , it will save false on app.use(session) and the saveinitialized. the saveinitialized is the session if not started/uninitiazation will store on session. it will set to the true. now deprecated warning will not show. 

till now we are doing the development, in development there is the 2 stage, which we done under our sysem and another is production stage: where other peoples are using our website, in development we can store the MemoryStore /session-storage but when we deployed then it will be the production envionment then we will not use the memoryStore then we will use the Session Store like:Cassandra Store, connect-dynamodb. connect-m0ng0. this all are temporary store which aere well known based on database. 
the one thing we can do is insiide app.use(session (the option that we define we can store on any variable and call that variable inside sesion.))
now we will learn more about the storing the user info:
inside session.js i create a one route called signup and inside there i will take name and with req.query i will extract that name: with the help of query string with register?name=dipesh, i can extract that name store into variable. if name is not exist we can give the default name. 
same like on count we give the req.sesssion.count to count the total visit. with the same object helps we can able to store the session & using info. on the signup route if we console req.session we get output like this:Session {
  cookie: { path: '/', _expires: null, originalMaxAge: null, httpOnly: true }} (also if we go to application and see details there it will also print the same on there. ) (by default there is alsway cookie on req.sessoin, by default httpOnly it always set to true.  )
  if we assign the req.session.name to name and console that it will print the value what have we added there. we store the req.session also we can use that value on another callback/function/routes. now if we go to hello route which we create we can see there that value we have added on the another route, which that acces. the better way to do that is redirect them to the hello route with that same value.

  connect flash: this is the npm package which we have to download. it is helped us to flash our messaegs.
  for examples on our listing website, when we  have done the crud operation the message should pop up of sucess or faillure message. it can pop of on the alert or added. but when we refresh that pages the popup shouldn't come. as those message who appear on single time. on this messagge there could be triggered. like when added different messagge should appear when added different message should appear. some messagees are showing the error.
  first we have to install the connect-flash npm package. it also comes on the middleware. for using the connect flash it is compulsory to use the express-session and cookieParser. for flash that specific message we write the req.flash, inside the req.flash we passed the 2 things, first we passed the key that based on the key we can identify that flash message. 2 parameter are key and message.
till now our flash is being done but we also have to render to the client side, for doing this we have to craatea views folder with page.ejs and inside there i will render that. i will render the req.seession.name which is on hello route now i will show in ejs. it keep says path is not defined i forget to require the path.
 res.render("page.ejs", {name: req.session.name}); (inside o bject i have to pass any value with req.session.name, the name which we passed on signup, now i can simply use the name object on my ejs.) #but we want that the req.flash message inside signup will flash on the ejs once .   res.render("page.ejs", {name: req.session.name, message: req.flash("success")}); (first i parses the req.session.name to access that name and i parsed the req.flassh with name called success to get access  which i print on page.ejs); the error i am encountering is that flash will only print once and i already have printed on console then it is not parsed to the ejs after delete the console line it worked.the flash message will only print once and then will vanished. (even though it preseneted on the ejs but it will only come once for temporary and after one time it wil vanished.) 
 res.locals: with what we rendering the templates from the res.render insetad we can store on res.locals. when we need to use the som variable, the flash message is on res.render instead we can do that pass on res.locals.  res.locals.message=req.flash("success");
  res.render("page.ejs", {name: req.session.name}); (i passed the value of success and render it.) (it works same like this on beefore. ) (when it will be the helpful, till now we only pass the success message, but we want to pass error message we can't store on res.render instead we store on res.locals) we pass the two condition if we leave the name default it will flash different with check on if condition with store on error variable  else user register message with succcess message. with this way we can create a diffeerent keys. for using this the better way to is use the middleware.
  i pass on the middleware with app.use and store thos 2 msg and call next i don't have to use no more on thaat route, it work away like above. 

  now the session knowledge will implement on this project:
  first i install the express-session pacakge, and then i require const sessionUpdates with i also use the app.use with session and sessionUpdates and if i check on application of insepcts we can see there a connect.sid which mean working now.
  inside session now we will go deeply of cookie. inside express-session npm there is the option of cookie by default the cookie value. the value are: path: '/;, httpOnly: true, secure: false, maxAge: null. we can change this cookie value manually. 
the cookie task is to track our sessions. by default the cookie doesn't have the expiray date. as this called a "non-persistent cookie, and it will delete on a condition like: exiting a borwser application. 
for ex: when we logged in oon github and and when we again try to logged in after 7 days without using we again have to logged it again like on facebook for 21 days, this is called a cookie session. but when we set the expiry date it will save till now. 
inside session i use this :   cookie:{
    expires: Date.now()+7*24*60*60*1000,
    maxAge: 7*24*60*60*1000,
    httpOnly: true,
  } (expires mean it will till that time will store the cookies, Date.now() current time to +7 days*24 hour O* 60 minutes * 60 seconds and 1000 millisecond and i will set the maxAge to same for store till that time, httpOnlly set true to helps us to safe our site from the cross site vulnebrity attack. we can verify that going on application of inspect.)
till now we have done the cookies operation now we willl opeate teh flash message.when we create a new listing it should flash above of saying the new listng is created. teh one things we have to ensure is that, before the app.use routes i have to use teh flash method so it can go on all of teh the route.
first inside on listing.js file i have send the res.flash message with variable name and the message with separated by comma, then i use the app.use(flash()) with the same name that we required, i will createa a app.use again with 3 parameter with inside i passed, the: res.locals.success=req.flash(success); 
  next()
) The next() function in Express is a built-in function that is used in middleware to pass control to the next middleware function in the stack. If you don't call next(), the request will be left hanging, and Express won't move on to the next middleware or route handler.

(first it will store the success message on locals #most importantly we have to call the next to operate the another next call. for use this inside the inde.eejs i have to make the structure of that flash message. the flash message will only for once if we refresh it, it will never come again.)
now in the next steps, we will define the success and failure message partial. the error is due to the typo error it should be success i write the succes on listing.js file of route. till now the flash message doesn't look good which we can improve by teh styling:
we can use the different alerts but for now , we will use the bootsrap flash. instead of showing our message inside the index.ejs we can simply showing our success message to boilerplate.ejs. like we created the a new template for the success template. 
inside include folder i will create a new ejs folder called: flash.ejs (for the template): inside there i include the flash file inside class with like this:  <div class="container">
   <%- include("../include/flash.ejs") %>
 </div> (why just before the body, cause we want to show before the body. now message is showing. now with the bootstrap alert message. we can show the user but it is still not fully functional. cause it will still show even we don't add any new listing, it will still show that alert.) for the understanding the success that we send to our client side is array, even though if we don't send anything it is empty array, and that empty arrray keep going frontend and take his space. for solving that we also have to add one more condition inside flash.ejs of && success.length (mean there should be some value on array, now it will work as expected.)
 we can create a dismits alert inline of fade show. we also have to create a button and if we click on tbat button that alert will be vanished. i use the bootstrap dismissible method and make z-index top of that things to fix it.
 now we can do that with the same logic we can implement on different routes like delete, update, edit, and review route. i just add the req.flash ("success", "review deleted") like this on listing.js and review.js with also on review routes. 
 error flash message: let's suppose you have the listing and that listing is deleted and if you again go to that url we will redirecterd them to the all listing with flash message show saying that the listing you trying to access is deleted like that also we can do similar to the updated old id.
 i just make on show route with if does not exist just show the res.flash("error"). till now i haven't make the error message on app.use method on app.js i have to create that. in ejs we have created a success flash we also have to create for teh error route. now that works we also can apply that method to the update route with previous id. 

 Authentication & Authorization:
 Here's a more condensed version:

Authentication vs Authorization
- Authentication: Verifies user identity (e.g., login).
- Authorization: Determines user access to specific content after login.

Password Storage:
- Store passwords in hashed form (e.g., Bcrypt), not plain text.
- During login, hash the input password and compare it to the stored hash.

Hashing:
- One-way function with fixed-length output, making the password secure and unrecoverable.

Salting
- Adds random data to passwords before hashing to prevent attacks like reverse lookup.

Node.js Authentication:
- Passport.js: Middleware for authentication with various strategies (e.g., Google, Facebook).
- passport-local: Basic username/password authentication.
- passport-local-mongoose: Simplifies Passport integration with MongoDB.
//In depth on auth.txt and i have to downloadd the npm i passport-local, passport-local-mongoose

now we have to define the user Model: inside models i will create a new file called user.js. in signup/login there could be the multiple of pages we can , for now we will just start with smallest number of fields. first we required the mogoose and Schema, now we will start with the email, username and passport. #but the passport-local-mogoose autmaticaly creates add a username and password automatically hash and salt field. for now we just creates a email field. userSchema.plugin(passportLocalMongoose); (it will automatically creates a username and password)
password-mongoose add some method to your Schema automatically, like set password, change password and much more method will automatically implement. (method meaning will understand when we work on project.) 
configuring Strategy: we have to apply the basic settings to use a passport-local first we will require on app.js.
for implement the passport we required to have the session, we can track the session we will just use the passport session, just use on app.use(passport.initialize()) (for track you can say it's a rules to configure before implemet to.it's a middleware that intitliaze passport )
passport.session() (it helps us to identify the users as they browser from page to page. it will associsated with each on user)
passport.use(new localStrategy(User.authenticate())); (this middleware will passed all of the request that comes on our site will have to pass from our middleware.)

passport.serializeUser(User.serializeUser);
passport.deserializeUser(User.deserializeUser); ( generate a function that is used by passport to serialse user into session, the all of the users data is stored is called seriealise and unstore called unseriealise. )
create a new route called register to:
//fakeUser signup
app.get("/fakeUser", async (req, res)=>{
  let fakeUser=new User({
    email: "dipeshsharma@gmail.com",
    username: "neww"
  })
  let newValue= await User.register(fakeUser, "password")
  res.send(newValue)
  // console.log(newValue);
  
}) (inside here i create a fakeUser with User same name as defined reules. with the register method, i can able to do: Instead of you having to write code to: Salt before hashing password, Hash the passwor, Check if the username already exists, Save the user info, Set up authentication, register does all of that for you in one simple method. till now we haven't save the user and doesn't perform anything, the above method on app.use says that we will use localStrategy, seriealise, deserializeUser, and passportLocalMongoose use saying it.  ) 
next we will create a demo user, with there i createa a new demoUser route same as fakeUser with register.register(user, password, cb) (with passwords we also can pass the callback inside the register which will convert into hash function., it also create the option of whether the username is unique or not ) (this is the same of demoUser which i create a twice)
now we will add the functionality of with Signup User with both the get and post method. it will be the signup route)- inside the routes folder i created a user.js and inside there i import the experss. and also i exports to module.exports=router; then we will require the user.js on app.js. then next process is to that user.js create a app.use like 2 other i als changed their name for not being confusion from : review to reveiwRouter on the app.js. i creatted a signup routes inside user.js which is working now. now inside the views folder i created another folder called users inside there i created a signup.ejs form route. 
the signup route redirected to the signup.ejs. the username i copied from the new.ejs and also email is simiilar to username. now we will implement the post method. in signup route first i createa form with post method first i create a get route with just for the interaction i created a logic in post route, with first i extractedd the email, username and password. and the password is extracted in the form of user.register, which will hashed and salt the password for secure our site. 
Login page: get route. with i just created the same login ui of singup ui. then i created the router.post method: router.post("/login", passport.authenticate("local", { failureRedirect: "/login", failureFlash: true}), (in mean passport.authenticate(with the local server which we used where should we redirect and with send like a flash message. )

the one things i have improved is validateListing move to the routes with listing.js and imported that file on other files. 
connecting login routes:
we want to if anyone wants to create a listings they must have logged in before create a listin. how can we check if user is logged in or not? (use the req.isAuthenticated() passport method).
   if(!req.isAuthenticated()){
      req.flash("error", "you must logged in before create a listing.")
      return res.redirect("/listings")
    } (in here i check if the error is logged in or not if not i will show the flash we can redirect them to the login page.) (if we add this inside the route it will show the user details. but will now show the passsword ). for editing and deleting the route we can also copy the routes but better way to do is transfer our logic in middleware and pass that functioon.
    i created a new file name called middleware.js and there i wrote the login inside the module.exports.isLoggedin and pass that function to listing.js with before i require the file, on thing keep in mind we have to write teh ename inside the curly brace for destructured the function from the module. i also pass have to pass on other method, fo doing the crud operation.
logout route:    now we will implement the logout route.  create a get request and with that method we will logout the user. there is different approach to implement the logout but passport makes us easy to do that. already req.logout method exist, first it will use the serialse and deserialize user methos use then will delete the user from the current session. for logout them we have to write the req.logout , for logout them it is a own callback as parameter, when use will logout immediatly what should happended handled the callback. we can define the err parameter  (if sometime passport.js failed , then it will call that error otherwise pass the next(err) method). in case it didn't get error it will be empty undefined, we asdd the err paremter on if econditon else it will redirecterd to main page with flash message. 
add stylying to our signup.login. first i created a 3 navbar item, in any website you will not show all of 3 signin method, if use already logged in it only show logout vice versa. for fix that we will use the in req there is user information store, we will use that. mean if req.user is undefined mean it only show the log in method not logout vice versa. 
we can't directly access the req.user method that we can use on ejs instead on our app.use middleware of error and flash message we passed the req.user to the currUser variable:   res.locals.currUser=req.user; now with if condition we can implement on ejs) (the error i am encounter is that i passed the next 2 times on middleware)
login after signup - passport login package automaticly establsh login session, mean if we sign up we haven't logged in. as a user we signup we can verify on db but automatically logged in, in all of the platform it happened automatically log in we have to implement that. what we want is that when signup happened it shuld automatically logged it.  when database is stored it will automatically logged in. 
req.login(registeredUser, (err)=>{
     if(err){
      return next(err);
     }
     req.flash("success", "welcome to the airbnb");
    //  res.redirect(`/listings/:${req.body._id}`);
    res.redirect("/listings");
 }) (i pass with first show error if any gogt errror else do next step. )

post login page:
when we create a new listing and after logged in it redirected us to the main page, for user convenience we will redirected them to where they left.  for building the functionallity one things we have to know in request object there is lots of information is stored, when i print the console of req from middleware.js we will see all details on there. even it will tell what path we are trying to access, also stored the session related info. i also console the originalUrl to check our url. this is the originalUrl we want to redirected the user after the login. 
we have to save the originalUrl which is a url on the middlweare before redirected there we only want to redirected them when user is logged in . we only save when user is not logged in. we will store dhte req.session.redirectUrl=req.originalUrl (in middleware). the flow of this approach: when user is logged in successfully then instantly where is her trying to access the url, we will redirect there.
but there is the one problem we can redirect on req.session.redirectUrl (but in passport.js when the req.isAuthenticated and success the passport in default wil reset our session. and the response will get the undefined. ) for fix that the redirectUrl will save on local variable where the local is accessible everywhere,  where passport don't have the access to reset our session. 
i created a another module.exports if teh req.session.redirectUrl exist we will store that value like this:  if(req.session.redirectUrl){
    res.locals.redirectUrl=req.session.redirectUrl;
  } we will call next then we also have to call hte middleware on user.js and use same name on login route, also don't forget to require the file on user.js . 
  we have done but there is the error, when we directly trying to login it will show page not found cause we will redirected where they left but now: when we diretly login at that time isLoggedin in triggered, and then thre redirectUrl is not exist which wil casue the error. wwe can create new variable and check conditon.  let redirectUrl=res.locals.redirectUrl || "/listings"; (it check the condtion.)
  #the smalll flaus we have to know like the small details we are trying to add on our website we have to know clearly, in case any error got during implement which will get the reason.

  listing owner:
  next with all of the listings we will associate with the owner. why it is necessery to associated with owner. we can correct authorized to the user. it is like giving permission to the correct person. this is also the  authrrization. till we only giving the lisitng to the listing later we will also give the user of owner to delete any reviews. before this we have to add the owner property. for this we have to add the owner from the schema. inside the listing.js inside the models we will create a single ownder object array. for that the owneer also should be the registered user. with giving the ref to owner.
  if we check on dbs the data will not be initialiazed yet , as we haven't initialiazed yet the Owner before this due to this we can't see the owner of any listing.
   for changing that we will initialized the database. one things we ccan do is inside the data.js we can give the owner property . also we can add the owner in bulk for all of the listing. also we can addd the objectId for everyone which is repeatable things instead  we will go to index.js which initialiazed our database. i copied any random listing objectId,     initData.data.map((obj)=>({...obj, Owner: "67b4cee58dc05bd3c54a3302"})); (it gives the every listing owner of same name to eveyone. ) the map function will create a new object with returning new object with the changes. now it associated with the obejct id each one for. inside the route listing with id route we can .populate our reviews as it is multiple owner we can populate it.  remember that when using Mongoose, if a reference field isn't populated, it just returns the ObjectId. .populate({
    path: "reviews",
    populate: { path: "author" }
  })
  .populate("owner"); (with this only becomes the populate)
now with the populate method i am not able to do that instead i add the owner name for each on of data.js. if we just show the listing.owner it will print all of teh data we just need username so we can write owner.username to show it. this is for the previous data but for creating a cofiguring with the new user:
@the error i am encouter is logina dn signup porcess becomes too slow. also when i add a new listing it is not configuring well to username route. fix that.
now we will start authorization:
now we will make the limit which person created those listing only can edit and delete it. now i have to delete and edit button who are not the owner of that listing. for hide that feature from the user we have to know the who is the owner of listing. and who is the user that trying to edit/delete that listinng. the current user is stored on locals and compare to the ejs template listing. we can make the condtion like: if(currUser && currUser._id.equals(listing.owner) )
.equals is a method of comparing between two. like == method. also on in case middleware is not running or get the error that mean current user is not saved in that case we can check with currUser with && condition and check both conditon. it is running but the username is not showing in some listing and also some is got error of username. the error i am encoutered due to the .populate("owner") method. the error of async true is ejs also take the html comments. so next time don't comment any html on ejs template. yes we made only on front end side but if we send a post request from the hoppscotch we can bypass our logic for this we also have to make the logic on database.
for making the authorized for the listing: 
this is for setting the authorized. in the update route . in the put show id route it is findByIdAndUpdate si working on there. now we will separate the findByIdAndUpdate will separate into two parts. cause we will find where that listing is located and will check if that user stored on res.locals is that same user only we will give access. i have not fully read this topic .
now we will set the authorizatoin for listing:  for this with every review there should be the author, and for deleting the review only author will have the access to delete. 
first i give the types fo author on review.js of omdels models. like we can see post on linkedin but can't post the comment on there same implement we will apply here. we only show the leaev a reviw option to the logged in user with add the logic of if(currUser) on show.ejs. now we have protect frontend but can anyone send the request from postman or hoppscotch , anyone can create without logged in. i just pass the fucntion on review.js with require from middleware. now how can we store the author. @i got the error of not submitting the reviews. #didn't watch the part 2 for creating a review.
in our project we have build the core funcitonality till now, mean this understand will not only used on this project it will used fro on any porject. : 

phase 3 in here we build the extra thing:  for making a better we will add more feature.
MVC: Model, View, Controller (Implement Design Pattern for Listings) (mvc is the term in development, it will not add anything but make better of existing code.)
in the designed code where eveything is there, backend frontend and database, how it code is written. we divide into 3 components. 
this is our just pattern mean fixed way to write the structured code:(models: all of the models is written there and it uses is store the database. view: render the frontend code,  controller: we will store the core functionality of backend)
insdie the listing.js of routes, there is the asynchourns callback which will shifted to the another file, so that routes folder are compact more. in our code we must possibly create the must readable code so with us other everyone can understand the code which file located here. 
all componenent inside the models segregrate is helped us to do mvc. all of the callback we will move to another folder. we have first created a controller folder. inside there we create a fild name: listings.js.
the asynchouns call back indside routes folder and listing.js file, we will shifted to the listings.js inside controller. 
"/", wrapasync (index) instead i use teh (listingController.index) (which runs and i already imported the listingController above from my controller model.)

the one things i have done just now it might occur error later. on routes listing.js validateListings shifted to the utils validateListing converted to models and i require there and used it there 
const listing = require("../models/listings.js"); (i think it should be the listings.js but when i use that i got the error)
now all of our callback function will shifted on the controller:
module.exports.contactForm=(req, res)=>{
  res.render("listings/contact.ejs");
} this is listings.js and this is listing.js: //go to contact form
router.get("/contact", listingController.contactForm)
(i make the mvc)
i have done same with make the separat on for all of the 3, listing, user and review. it can't pas the multiple of middleware only 1 can pass, before this it got's me the error instead i will not pasas the middleeware which then working now.

Router.route: a way to group together routes with different verbs but same paths.
in initially we write all of the app.get and app.post all of the method we writtern on app.js and then based upon what they are we shifted them to the routes folder. the all of the router we written here , is also there is a way to written in compact way which is the router.route. intead of making the multiple logic for the same routes as differeent mmethod we can simple write Router.route adn can simply write all of the routes mehtod inside there:
router.route("/login")
.get( async (req, res)=>{
  res.render("users/login.ejs")
}) (i define with this way)
no i will just do with all of there.
rating are shows in the not quite good way like i have to restyle our rating. in other website start froms are shown.
till now the stylig of rating is nly the range based which is quite not good i have to improve. we will use the starblity library to shown the how many stars. now we will copy the prefered css and create a new file called: rating.css inside public folder. when we copy paste the starblity slot css to rating.css. i have to import them on boilerplate.js:   <link rel="stylesheet" href="/css/rating.css"> (i import in boilerplate.js ). then i paste the starblity-slot which working now.
<div class="card-title"><%= review.author.username</div> (i added this @it might be cause the error. ) and after this line:                 <div class="card-title"><%= review.author.username</div> (it might also have the error) 
if we want show the stars according to range the above is code. now we will complelety remove the range order to this starblity rating. 

@the error i am facing: i am not able to submit the rating, as it get the cannot get post error and also when i logged in i am not able to logout as it says cannot get logout error.  
finally i find the error th error is i didn't require on review.js to happened this event. and also i have to add: const router = express.Router({ mergeParams: true });
(for the requring a i require the child which is required. )

image upload: image upload process is quite lenghty process but with our code we can't directly send images to backend, 1) backend only recieving a raw format like raw text with this code backend can't accept the image format 2) size limit: we can send but when files comes in backend where will we save the files. we know on mongodb only bson format data is saved. in bson there is the limit in bson there is limit for file size.
we will make our form capable of sending our forms to backeend. now first we have to maek the form to accept our files. with form capable of sending files. second steps would be save those files. we will not use the mongooes to save those files. instead we will use the 3rd party service. those service are cloud service famous is aws cloud. till now we are not doiing teh production level as right now we are just doing the development for that we will use 3rd party service just for development. the party service is to save our fiels. they will give the url link of the links. 3rd steps would be save this links on mongoose.
first steps is to manipulate our forms. till now form only can send the urlencoded data which we use by sayng the express.urlencoded. for sending the files we will create a new parameter. which is the enctype: "multipart/form-data". (encodedtype). multipart form data are capable of sending data of multiple forms.
<form class="row g-3 needs-validation" action="/listings" method="POST" novalidate enctype="multipart/form-data"> (i added the enctype enctype are just 3 types) .post((req, res)=>{
  res.send(req.body)
}) if i just send the req.body, we will get the empty object.th reason is to get the empty object is, when new data is parsing it will not understasnd for that we will use the parser. for handling that we will use the multer.
multer npm package is a middleware for handling the multiapart/form-data which is for uploading files. multer will not process any form which is not multipart. const multer=require("multer");
const upload=multer({dest: "uploads/"}) (with this way i required and i have to defien teh destination of the files. this mean for parsing the form data we will use the multer, from the forms multer will extract the files. and will save the images inside the upload folder. ) that mean we say file will be where saved, for saving the files actually inside the routes we will use the upload.single("field-name) 
.post(upload.single("listing[image]"), (req, res)=>{
  res.send(req.file)
}) (upload single mean one file at a time and where is our database location define there and what we want to show req.file mean file details, it show output like this;{"fieldname":"listing[image]","originalname":"dsa-core-concept.png","encoding":"7bit","mimetype":"image/png","buffer":{"type":"Buffer","data":) 

cloud setup: we will use different third party site but for now we will use the cloudinary & .env file. 
first we will crate a account. and on product envionment credintials we have to authorized our code for get access of files. for our code we have to get the credintials. we share the code but we will never share the credintials. this is important piece of info. in credintials there is 3 thing: Cloud Name, API SECRET and api secret, api envionment variable. this credintials impoortant credintials details write on other files. which we not upload on internet.
for saving all of our credinatial info we will create a new file extension which is .env file. .env task is to store our envionment variable.  the file name will not have only .env i will create on outer file. we will store the SECRET with : SECRET=value, SECRET always will be the capital and there will be not any space and double quoted. once the environment variable stored on .env we can use anywhere on our project. it will load enviviorenemtn variable from .env file. 
the .env files we can't directly access that, for accessing that we will use another third party libarary called: dotenv (npmpackage) . it will not worked on dependency it will work as indepedent. 
we have to ad the condition of if(process.env.NODE_ENV!="production"){require("dotenv).config()} (we are currently one the development phases in here we are building the projects and deployment is deplying our website. .env file we only use on development phases not in production phases. never upload the .env file on github. later when will hosting, deploy the credintials we store on .env wil see the another method. during deployment time we will create a new envionment variable of node envionment to set production when our envionment value is not production  then we will use other ise not) we have to store the credintional of cloudnary not our credinatial. remember that don't use any space, comma, semicolon, just go next line. 
for storinng our files, we will use the multer store cloudnary, for that we will use the two npm libarary one cloudinary and another is: multer-storage-cloudinary.  
as right now we have installed a lot's of libraary: this is huge topic we have to install , later on we have to do own research for our own product it will take time, don't worry. as right now for feature we know the librarry which we feel quite easy, but when  we try to implement our own thing on website it will take time to research and do . 
we will install two package, cloudinary and multer-storage-cloudinary. for using them we will create a individual own file. in there we will configure a init cloudinary. 
@the error i not showing the picture file which i upload on the internet. also show the npm error when we trying to download the package of cloudinary.
first i created a file name called:cloudConfig.js which i will use only for the configuration. we have to configure first. for configruation we have to authorized the cloudname, apikey and api secret. 
CLOUD_NAME=dsK2821po
CLOUD_API_KEY=7514764292881
CLOUD_API_SECRET=t6Utbfidid
(this is dummy i changed the api code due to security reason, this is the cloud info which is not share with anyone i copy from my cloudninary api keys and pasted on the .env but have to give the name by own) cloudinary.config({
  cloud_name: process.env.CLOUD_NAME,
  api_key: CLOUD_API_KEY,
  api_secret: CLOUD_API_SECRET
}) (i have to config on config.js file with the same name with givn name before this i also hav to reuire those 2 npm package after installing. ) (in .env we can give any name but on cloudConfig.js we have to give the defailt name.)
now we will make the storage of those files where will we store it. const storage=new CloudinaryStorage({
  cloud_name: cloudinary,
  params:{
    folder: "air-bnb-clone",
    allowedFormat:["png", "jpg", "jpeg"],
    // public_id: (req, file)=> "computed-file"
  }
}) (with this way like giving the name and folder name and allowed format we have defined the storage location. )
module.exports={
  cloudinary,
  storage,
} (we will both export them and where we use them on our listing.js. )
const {storage}=require("../cloudConfig.js");
const upload=multer({storage}) (first i require the storage on listing.js and then i show the upload file location )
now our form will send the data to backend and can parsed now. 
{"fieldname":"listing[image]","originalname":"5be3643c2ac3458b207ee9047.jpg","encoding":"7bit","mimetype":"image/jpeg","destination":"uploads/","filename":"8e7be0d055cb9d87fbdb614c690f631b","path":"uploads\\8e7be0d055c87fbdb614c690f631b","size":105791} (now if we upload any files, now it will take some millisecond to send data to bakcen diand send this knd of raw file with the image link, as depending on file size it will take that time ammount to load it.)


5be3643c2ac3441bff5358b207e047.jpg (the link i am getting wil stored on mongodb database);
first we have to modify the listing schema first our image schema is just simple string. in our image now we will store 2 value. first we will save the path(file url), and also save the filename.:image: { url: String, filename: STring } filnenmae not that effective right now but it will require later. in later when we want to update the file then filanem would be useful. rest of the would be same just 2 values would be added on image. one will come url and another filename. 
if we try to run our website it will break cause based on this our entire website is mmade.
in listing.js router.post("/",upload.single("listing[image])), i will use upload.

listing.js image update. now i passed the upload.single inside that post route. the upload.single file logic will write on controller. also i do one thign validateListing is move after the upload.single cause it willl cause the error. now inside the controller listings.js: i will use the :         let url=req.file.path;
          let filename=req.file.filename; (to get the url and filename fo that file. ) file mean entrie object and path mean url and filename what types. now if i just print the console.log(url, ".." filename) (it will print it)
 const newListing=new Listing(req.body.listing);
          newListing.owner=req.user._id;
          newListing.image={url, filename};
          await newListing.save();
          req.flash("success", "New listing created") (but first i have to define teh newlistign otherwise it will not worked then i can use the newListing.image={url, filename}) (with this way it worked not)
          @but my websitei is too slow when i added a new listing it takes too much time to load it. it take delay to save on the backend.

image: {
    url: 'https://res.cloudinary.com/dsjok71po/image/upload/v1740240790/air-bnb-clone/vhoe8x3x2vgvatvei.jpg',
    filename: 'air-bnb-clone/vhoe8x3x2vzyvgvatvei'
  }, (when i search on the db, i find the image url and filename like this.)

we have done the 3 step but it is not showing to the frontend. as it update the backend.
my previous code:     description: "A stylish modern condo offering fantastic city views and a central location in Seoul.",
    image: url: "1.jpg" to image: { url: "1.jpg", filename: "listing-image-25}  in my entire data.js . now i will again run the data.js to restart my database.
now i have the change the url of index.ejs and show.ejs from:<%= Listing.image %> to <%= Listing.image.url %>. also on show.ejs. now display image work as expected. generally in bigger website there is fille limit of image file size, cause we have to rent out the cloud data store, if there is not limit, eveyone can upload high images, which will increase our cost.

now next steps:
edit listing image, preview image.
once the listing is edited, how can we change the form. but in the edit listing there comes the url, which we have to change to file upload. first on new.ejs form i added the enctype.
first we will make capable of forms to accept the files and send to the backend.we will change the routes of backend, that accept the image data, on req.file. upload that file on cloudinary . then we will have the acess of filename and url, then we will change database. 
now i will make the form capable of updating the listing image. we will fix the edit.ejs same like we fix the new.ejs. first i will make the encytype multipart, now form can accept the image but how can it will send the backend. in my listing.js route: i add the same method of sending data before validateListings both on put and post route of new and edit. when it is updated on updateListing i put on the variable, the update.

  let listing= await Listing.findByIdAndUpdate(id, {...req.body.listing})
  let url=req.file.path;
  let filename=req.file.filename;
  listing.image={url, filename};
  await listing.save(); (first i save on the variable of name listing of previous save, then i save teh url and filename from the file.path and filename) then i stored them on the url and filename which is our data.js image object. then  i saved.
  but there is the catch: if we didn't upload the any image leave just as it, the new the url and filename will be blank and store the undefined value on backend, for avoiding that. for that first we will check if req.file existed then we will only update otherwise not. in js for checking any variable undefined or not we can check by typeof undefined like this:
    if(typeof req.file !== "undefined"){
  let url=req.file.path;
  let filename=req.file.filename;
  listing.image={url, filename};
  await listing.save();
}   (it just check the condtion of the whether if req.file is not blank mean new image is uploaded then it will run this condition)
@when i create a new listing the error comes listignSchema is not defined with create with the image)
image preview for listing: for updating the existing listing, we want to preview the old listing what our old picture look like. then user can decide whether listing should be updated or not. inside the edit.ejs:   <div class="mb-3">
        Original Listing: <hr/>
        <img src="<%=listing.image.url" alt="<%=listing[title]">;
    </div> (i show the old image just before the file, but there is the catch if someone upload at high quaility image it will also show the high quality on there with cause the error, like it will take too much time to show, instead we will compress that image, this is just for the edit.ejs and not for the show.ejs) 
we also can compress the picture quaility but also cloudinary also provides us the multiple option of transfom of image. for ex: if we want to blur the image we can simply do the res.cloudinary.com/demo/image/upload/e_blur: 300/sample.jpg (with this way we can blur the image, this is due to the cloudinary internal api) 
how can we compress that image: who render our image inside the controllers folder of listings.js. if(!listing){
    req.flash("error", "Listing you requested is doesn't exist");
    req.redirect("/listings");
  }
  let originalImage=listing.image.url
  originalImage.replace("/upload", "/upload/w_250"); (first i extract the image url and i replace with upload to add the height and width, we can change any parameter.then i also render the originalImage.( i miss the one thing if user go to listing that doesn't exist we will show the flash message and redirected to the lsitings))


Maps:
now we will study the map feature. we will not use that much but it is quite good. in any listings site at the end it will show teh location of that listing. we will use the maps api for showing the api. there is the google maps api which have the intersting feature. like: calculate shortest distance, seeing the neighbourhood area and much more feature we can explore. it will require the credit card and debit card to use it which we will use the mapbox. accessing token mean is that user is authorized to use that token to just check in the currect user.
for using that first we will have to use the access token from the mapbox and that accesstoken will store on .env.
for displaying the first map. the project is shows from the mapbox but it required the credit card that's why i use the maptiler.
as right now i am learnign from other, due this this it is straightforward. but when we try to implement our feature it will take lot's of time, as we have to research and fix the bug. we display a map on webpage. generallyl there is teh code for entire page but we only want on show.ejs. 
first i have to add the 2 line script on boilerplate.js for the maptiler.  <div class="col-6 offest-3 mb-3">
          <div id="map" class="col-6 offest-3 mb-3"><h3>Address:</h3>
          </div>
          </div> (i added the basic of where will it located.)
          <% if(listing.reviews.length>0){ %> (i aded the logic of if only reviews exist then all reviews will be shown)

      maptilersdk.config.apiKey = 'YOUR_MAPTILER_API_KEY_HERE';
      const map = new maptilersdk.Map({
        container: 'map', // container's id or the HTML element to render the map
        style: maptilersdk.MapStyle.STREETS,
      }); (in here first i passed the api key and then inside th function i give em );
 let mapToken="<%= process.env.MAP_TOKEN %>"
  console.log(mapToken);
    maptilersdk.config.apiKey = mapToken;
    
      const map = new maptilersdk.Map({
        container: 'map', // container's id or the HTML element to render the map
        style: maptilersdk.MapStyle.STREETS,
            center: [23.4653, 67.6983],
        zoom: 9, 
      }); (with this way like first i store the maptiler on mapToken then config and give now it shows the small map on my page, center mean longtitude and lattitiude and zoom mean how much bigger zoom. )
all of our code have the access in ejs file, now from the ejs i will access the script. in script i will save the environment variable. the js file will saved where will store on public/js/map.js: i stored those into map.js and the script can't accept the ejs that's why the process.env value is stord on script tag and then use the same name to the map.js .


GeoCoding Important:
GeoCoding: GeoCoding is the process of converting address (like a street address) into geographic cordinated (like lat. and long.), which you can use to place markers on a map, or position on map. till now our map only understand the lat and long. so we want to convert our address to lat and long which only understand our code. 
when we add a new listing how can we convert into lat and long. 2 types of geocoding are avaible: forwardd goecoding: turning kalikalanagr, butwal into -27.248,29.248. reverse geocoding: -27.248,29.248 into kalikanagar butwal. the suggestion we get when we put some address it possible due to the geocoding. 
for using the mapbox sdk js goecoding i first require on listings.js: 
 let response= geocodingClient.forwardGeocode({
        query: 'Butwal, Nepal',
        limit: 1
      })
      .send() (inside the post listing i require the geocoding with foreward mean string to lang and long query can be anything, and limit mean we only want 1 response.)
      @i am still getting error of not able to show teh geocoding.
      we will just change the query to: req.body.location which we get what we search for.


Storing the coordinates:
GeoJson: teh most simple structure in GEoJson is a point. Below is an example of point representing teh approximate location of any place. in GeoJson long. comes first in GeoJson array. for using all of functionalities we use teh GeoJson, 
Ex: {"type: : "Point", "coordinates" : [ -152.5, 37.5] }
what's the usage of saving a data in GeoJson, the mongoose.
now first i have to define the schema : geometry:{
  type: {
    type: String,
    enum: ['Point'],
    required: true
  },
  coordinates: {
    type: [Number],
    required: true
  }
}
 (this mean , i give the typeString, and this is Geojson format of enum will be point, first come long and lat, and i given the coridanted will be the number in form of array. ) i call the geocodinng api maptiler with using the axios. 
 newListing.geometry = response.data.features[0].geometry.coordinates; (first )const feature = response.data.features[0];
    const geometry = {
      type: "Point",
      coordinates: feature.geometry.coordinates,
    }; (response data feature will give the output of an array, only first one mean long and lat, then cordinates will hold teh value of it. )
this following marker we can't directly access to the js file as these long and lat only can accept on ejs form )
<script>
    let mapImport="<%= process.env.MAP_TOKEN %>";
    let coordinates="<%= listing.geometry.coordinates %>";
  </script> (as we directly try to use this it will give an error, so we have to convert this into jsonStringify, with ejs be <%- and JSON.stringify() , it will convert tinro json string.)

now i will map marker the location of where we should tick the exact location. 
const marker = new maplibregl.Marker()       // Create a new marker instance
      .setLngLat([77.1025, 28.7041])              // Set marker position: [longitude, latitude]
      .addTo(map); (i first define the default marker position on map.js )

# solved error, i failed missureably on finding the error of insdie the postListing, as i constant get error. now i will move forward to day 54 and look back day 53 afterwards.

the erro is that i have not imported a one module using the scrript. which i have done that. now my next task is to align with the . now can even change the label of map by just changing the style.
the error i finally encouenter is that:     let coordinate=<%- JSON.stringify(listing.geometry.coordinates) %>; i shouldn't use the double quotes on here when i put on double quotes it converted to the string, not a array but we want in array format that is causing teh error.


now this is day 54: we will change the webiste home .
first fof the homepage. now we will add the filters like on airbnb. after the navbar. first i change the entire navbar look . now i will add the other things on after the navbar which is similar to the aibnb. i have added the html of top choice:  <div id="filter">
        <div><i class="fa-solid fa-person-breastfeeding"></i></div>
        <p>Trending</p>
      </div> (with multiple choices.)

#i have addded the frontend of showing from the tags, but if we really want to implement we can simply divide them into models listing.js and give each of one and work on that. i could work on that.

now i will work on switches: it's a toggle switch, when we click on that it will turn on or turn off. i added the switches and make the text reverse. now i want to perform something when i clicked on the toggle option.i can do this with event listener. now i have done the addEventListener now i will add the fucntinoality. 
we have 2 option, when we want to hide anything: visiblity hidden , mean it will hide from the code but it will occupity the space that it take. on display none, it will not shown and it will also not occupiy the space

 let toggleSwitch=document.getElementById("flexSwitchCheckDefault");
      let priceBefore=document.querySelector(".price");
    
      toggleSwitch.addEventListener("click", ()=>{
        // priceBefore.textContent=(priceBefore*.18)+priceBefore;
        let tax=document.getElementsByClassName("tax");
        for(info of tax){
         if(info.style.display!= "inline"){
          info.style.display="inline";
         }
         else{
          info.style.display="none";
         }
        }
      }) (with this logic i can simply add the if display is inline then do condition else another condition.) 
      we can change teh search button .




now using the mongoose atlas. now we have stored the data on cloudinary now we will use mongo atlas for cloud database service. now our complete database will shifted to the cloud/online. first create a account on mongo atlas. in storage there are 2 types are storage: individual storage and shared storage. individual mean we only can access and shared mean that storage can use anyone but can't have the access to the other. for set the authentication we have to set the username and password. note the username and password. now on we can create user. what does it mean create user, when we create any database . till now we only created on local host. in our localhost db, from vs code when we want to do read write we can do that. we can set who only can read access and who only have write access like this. it is like different level of permission to user. like college student don't have the access to change marks while teacher have like this.
i have add the password. now i have to connect to the local envionment  which requires the ip address. when we will upload to the internet we have to get the local environment for hosting: option are render and heroku. when we will deploying it will move to cloud. when it will go online we have to added th online ip. 
how can we connect the local project to online database. when we will connect to the node.js it will show the database link of string. we have to copy and change the passwrod to your password. we have to add that string to app.js, where we connect to the mongodb of MONGO_URL we will change there. i store that password to env first, we will later not pushed the env file for security purpose, i first add on env and i changed the mongo_url to that process.env with any name and replace mongoose.connect with that same name. now we can check all of our data that we added here will not shown we can add any new listings now.

mongoose session store. the next thing we will se before deployment is mongo session store with connect-mongo. as i remember that we use express sesion. the storage we use is local storage. the session storage not made for the deployment it meant only for the designing and development. due to it will leak memory, under most condition and cannot be teh scalable. it is only meant for debugging and development.
by default session storage we have to change it. there are lot of option. also we have experience on mongo we will use service called: connect-mongo. the all of the cookie,  user expiry date, user token all of the will be stored here. for using this we have to install it first. we have to require the connect mongo and also  express session(express-session ) is already required. we can pass the connect-mongo as a middleware or we also can even pass as a variable: 
  store: MongoStore.create({
    mongoUrl: 'dbUrl',
        crypto: {
      secret: secret
    }
  })
  
 (with this we called where is our database,it will also be the advanced option, in advaned option we can use the encryption,  in here i pass the secret code: secret, i pass the same secret as above. )
 we also can pass the touch after which is common used method, like on facebook when we after logged in if we close that tab and again opened our accoutn will be still logged in, it mean if we do multiple times of refresh it will update the session information. whether the changes on session or not.  what we want even after refreshing, touchAfter mean that if there is no updation on session we wil update after the 24 hours. i moved this before sessionoptions and i also passed the store which is the name to insdie sessionOptions, it is mongo related information. now our session information stored on atlas database, if we want to store on local database we can simply pass the mongo_url, on mongoUrl. 
 we wil pass the another function after the store, for incase if there is the error on mongoStore, we just console and know where is the error. like this way: store.on("error", ()=>{console.log("Error mongo store", err);})
 now if we just run on atlas database inside the collection we will see another collection called sessions, why, in here it will store the session related info. back then when we using the local it was saved on memory storage now it will saved on atlas sessoins collections. in session it will show the last modified details , expires changes of the modified and expires. the information related our session, the maximum lifetime is 14 days if we didn't change anything which used to set : session.cookie.expire. if we want to change this interval we can change into any days. 
@i am getting error with mainly connecting to connect-mongo to mongodb. 


 Deployment:
 for deployment there are lot's of option, popular are: render, netlify and cyclic.  heroku now becomes the paid. we will use the render. first i will create an account on render. then my next steps would be defines the node version on package.json. why, cause if we didn't specify the package. when we deploying on render it might cause an error, so we have to define with node version like this.  "engines": {
    "node": "22.11.0"
  }, (just defines the engines which node version just define it.)
  the next things is that connect render account to the github accout. cause currently our project is on local storage. how can render get code so we have to upload project on github private push. from github render will take the information. when in future where we update any code we can simply push to github and said to render just update the code. the process would be too smooth, from now. 

  push to the git:
  git init
  git status (it will shw files that have not uncommit, )
  (in the github we don't want to uplaod the .env files which stores the sensitive information, and node_moduls all of the node modules files would be store on the package.json we don't need to upload it. )
  .env and nodue_modules (ignore this files.)
  create an .gitignore files (inside there put the .env and node_modules/ (/due to it's a folder), which mean git will ignore this two files.) (after this node_modules and .env file will come in gray color mean it will ignore those files.)
git add . (add all files)
git status (check that all of the files is changes added)
git commit -m "Add my first-mega-project files"
git status(it should shouw nothing to comming with on branch main)


//connect render to github
first i have to connect render to github (remember that only selected repo, as i only want to give access to my project not my entire profile.)
then i have to connect and given a name, regions, runtime(set to node), build command(set to npm install as we will install of package from npm install), start command (node app.js set node caus we only run one times that's why we don't use nodemon app.js), auto deploy ( we can set to no , on advanced option, ), select on create web service.
it will take time to it, if we just deploy that it will failed it, cause we use environment variable on multiple times on our code but we are not giving access to envionment variable which is why it cause as error.
for making successfull of deployment:
configure the atlas and envionment variable. till now our database is connect a local system but now we will connect with render. render will have different ip address. tha we have to store onn mogodb. so that atlas identify the white list of render ip. 
for adding the envionment variable. in environment i will each added the each envionment variable. first i add each environment with key and their value each. the 3 ip of render i have to add on network access of mongodb atlas . then i also force the install process cause cloudinary lower version cause the errror: npm install --force. now finally my project has been finished.

in the frontend after this i have learned the react and tailwind. now i should learn the: